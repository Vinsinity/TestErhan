// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name TestErhan
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFAudio
import AVFoundation
import Accelerate
import Alamofire
import CommonCrypto
import CoreGraphics
import CoreMedia
import CoreNFC
import CryptoKit
import CryptoTokenKit
import Darwin
import Foundation
import OpenSSL
import Speech
import Swift
import SwiftyTesseract
import TensorFlowLiteC
@_exported import TestErhan
import UIKit
import Vision
import VisionKit
import _Concurrency
import _StringProcessing
public enum PassportAuthenticationStatus {
  case notDone
  case success
  case failed
  public static func == (a: TestErhan.PassportAuthenticationStatus, b: TestErhan.PassportAuthenticationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class NFCPassportModel {
  public var documentType: Swift.String {
    get
  }
  public var documentSubType: Swift.String {
    get
  }
  public var personalNumber: Swift.String {
    get
  }
  public var documentNumber: Swift.String {
    get
  }
  public var issuingAuthority: Swift.String {
    get
  }
  public var documentExpiryDate: Swift.String {
    get
  }
  public var dateOfBirth: Swift.String {
    get
  }
  public var gender: Swift.String {
    get
  }
  public var nationality: Swift.String {
    get
  }
  public var lastName: Swift.String {
    get
  }
  public var firstName: Swift.String {
    get
  }
  public var passportMRZ: Swift.String {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var residenceAddress: Swift.String? {
    get
  }
  public var phoneNumber: Swift.String? {
    get
  }
  public var documentSigningCertificate: TestErhan.X509Wrapper? {
    get
  }
  public var countrySigningCertificate: TestErhan.X509Wrapper? {
    get
  }
  public var LDSVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  public var dataGroupsAvailable: [TestErhan.DataGroupId] {
    get
  }
  public var dataGroupsRead: [TestErhan.DataGroupId : TestErhan.DataGroup] {
    get
  }
  public var dataGroupHashes: [TestErhan.DataGroupId : TestErhan.DataGroupHash] {
    get
  }
  public var cardAccess: TestErhan.CardAccess? {
    get
  }
  public var BACStatus: TestErhan.PassportAuthenticationStatus {
    get
  }
  public var PACEStatus: TestErhan.PassportAuthenticationStatus {
    get
  }
  public var chipAuthenticationStatus: TestErhan.PassportAuthenticationStatus {
    get
  }
  public var passportCorrectlySigned: Swift.Bool {
    get
  }
  public var documentSigningCertificateVerified: Swift.Bool {
    get
  }
  public var passportDataNotTampered: Swift.Bool {
    get
  }
  public var activeAuthenticationPassed: Swift.Bool {
    get
  }
  public var activeAuthenticationChallenge: [Swift.UInt8] {
    get
  }
  public var activeAuthenticationSignature: [Swift.UInt8] {
    get
  }
  public var verificationErrors: [any Swift.Error] {
    get
  }
  public var isPACESupported: Swift.Bool {
    get
  }
  public var isChipAuthenticationSupported: Swift.Bool {
    get
  }
  public var passportImage: UIKit.UIImage? {
    get
  }
  public var signatureImage: UIKit.UIImage? {
    get
  }
  public var activeAuthenticationSupported: Swift.Bool {
    get
  }
  public init()
  public init(from dump: [Swift.String : Swift.String])
  public func addDataGroup(_ id: TestErhan.DataGroupId, dataGroup: TestErhan.DataGroup)
  public func getDataGroup(_ id: TestErhan.DataGroupId) -> TestErhan.DataGroup?
  public func dumpPassportData(selectedDataGroups: [TestErhan.DataGroupId], includeActiveAuthenticationData: Swift.Bool = false) -> [Swift.String : Swift.String]
  public func getHashesForDatagroups(hashAlgorythm: Swift.String) -> [TestErhan.DataGroupId : [Swift.UInt8]]
  public func verifyPassport(masterListURL: Foundation.URL?, useCMSVerification: Swift.Bool = false)
  public func verifyActiveAuthentication(challenge: [Swift.UInt8], signature: [Swift.UInt8])
  @objc deinit
}
@available(iOS 13, *)
public class PACEHandler {
  public init(cardAccess: TestErhan.CardAccess, tagReader: TestErhan.TagReader) throws
  public func doPACE(mrzKey: Swift.String, completed: @escaping (Swift.Bool) -> ())
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class OpenSSLUtils {
  public static func getOpenSSLError() -> Swift.String
  @available(iOS 13, macOS 10.15, *)
  public static func getPublicKeyData(from key: Swift.OpaquePointer) -> [Swift.UInt8]?
  @available(iOS 13, macOS 10.15, *)
  public static func decodePublicKeyFromBytes(pubKeyData: [Swift.UInt8], params: Swift.OpaquePointer) -> Swift.OpaquePointer?
  public static func computeSharedSecret(privateKeyPair: Swift.OpaquePointer, publicKey: Swift.OpaquePointer) -> [Swift.UInt8]
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup {
  public var datagroupType: TestErhan.DataGroupId
  public var body: [Swift.UInt8] {
    get
  }
  public var data: [Swift.UInt8] {
    get
  }
  public func hash(_ hashAlgorythm: Swift.String) -> [Swift.UInt8]
  @objc deinit
}
public enum SecureMessagingSupportedAlgorithms {
  case DES
  case AES
  public static func == (a: TestErhan.SecureMessagingSupportedAlgorithms, b: TestErhan.SecureMessagingSupportedAlgorithms) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, *)
public class SecureMessaging {
  public init(encryptionAlgorithm: TestErhan.SecureMessagingSupportedAlgorithms = .DES, ksenc: [Swift.UInt8], ksmac: [Swift.UInt8], ssc: [Swift.UInt8])
  @objc deinit
}
final public class QKMRZParser {
  public init(ocrCorrection: Swift.Bool = false)
  final public func parse(mrzLines: [Swift.String]) -> TestErhan.QKMRZResult?
  final public func parse(mrzString: Swift.String) -> TestErhan.QKMRZResult?
  @objc deinit
}
public struct KYXAccount {
  public init(organization: Swift.String, username: Swift.String, password: Swift.String, baseUrl: Swift.String)
}
@objc @_Concurrency.MainActor(unsafe) open class KYXViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any TestErhan.KYXViewControllerDelegate)?
  @_Concurrency.MainActor(unsafe) required public init(delegate: (any TestErhan.KYXViewControllerDelegate)?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) public func next()
  @objc deinit
}
public enum KYXViewControllerOutputs {
  case next(from: TestErhan.KYXViewController.Type)
  case dismiss
  case success
  case failure
  case detectFrontResult(result: TestErhan.KYXProcessDetectTypeResult)
  case detectBackResult(result: TestErhan.KYXProcessDetectTypeResult)
  case nfcResult(result: TestErhan.KYXProcessNFCResult)
  case livenessResult(result: TestErhan.KYXProcessLivenessResult)
  case speechToTextResult(result: TestErhan.KYXProcessSpeechToTextResult)
  case videoCallResult(result: TestErhan.KYXProcessVideoCallResult)
}
public protocol KYXViewControllerDelegate : AnyObject {
  func output(_ output: TestErhan.KYXViewControllerOutputs)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup11 : TestErhan.DataGroup {
  public var fullName: Swift.String? {
    get
  }
  public var personalNumber: Swift.String? {
    get
  }
  public var dateOfBirth: Swift.String? {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var address: Swift.String? {
    get
  }
  public var telephone: Swift.String? {
    get
  }
  public var profession: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var personalSummary: Swift.String? {
    get
  }
  public var proofOfCitizenship: Swift.String? {
    get
  }
  public var tdNumbers: Swift.String? {
    get
  }
  public var custodyInfo: Swift.String? {
    get
  }
  @objc deinit
}
public enum PACEMappingType {
  case GM
  case IM
  case CAM
  public static func == (a: TestErhan.PACEMappingType, b: TestErhan.PACEMappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class PACEInfo : TestErhan.SecurityInfo {
  public static let PARAM_ID_GFP_1024_160: Swift.Int
  public static let PARAM_ID_GFP_2048_224: Swift.Int
  public static let PARAM_ID_GFP_2048_256: Swift.Int
  public static let PARAM_ID_ECP_NIST_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P320_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P512_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P521_R1: Swift.Int
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getVersion() -> Swift.Int
  public func getParameterId() -> Swift.Int?
  public func getParameterSpec() throws -> Swift.Int32
  public func getMappingType() throws -> TestErhan.PACEMappingType
  public func getKeyAgreementAlgorithm() throws -> Swift.String
  public func getCipherAlgorithm() throws -> Swift.String
  public func getDigestAlgorithm() throws -> Swift.String
  public func getKeyLength() throws -> Swift.Int
  public func createMappingKey() throws -> Swift.OpaquePointer
  public static func getParameterSpec(stdDomainParam: Swift.Int) throws -> Swift.Int32
  public static func toMappingType(oid: Swift.String) throws -> TestErhan.PACEMappingType
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toDigestAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup2 : TestErhan.DataGroup {
  public var nrImages: Swift.Int {
    get
  }
  public var versionNumber: Swift.Int {
    get
  }
  public var lengthOfRecord: Swift.Int {
    get
  }
  public var numberOfFacialImages: Swift.Int {
    get
  }
  public var facialRecordDataLength: Swift.Int {
    get
  }
  public var nrFeaturePoints: Swift.Int {
    get
  }
  public var gender: Swift.Int {
    get
  }
  public var eyeColor: Swift.Int {
    get
  }
  public var hairColor: Swift.Int {
    get
  }
  public var featureMask: Swift.Int {
    get
  }
  public var expression: Swift.Int {
    get
  }
  public var poseAngle: Swift.Int {
    get
  }
  public var poseAngleUncertainty: Swift.Int {
    get
  }
  public var faceImageType: Swift.Int {
    get
  }
  public var imageDataType: Swift.Int {
    get
  }
  public var imageWidth: Swift.Int {
    get
  }
  public var imageHeight: Swift.Int {
    get
  }
  public var imageColorSpace: Swift.Int {
    get
  }
  public var sourceType: Swift.Int {
    get
  }
  public var deviceType: Swift.Int {
    get
  }
  public var quality: Swift.Int {
    get
  }
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
@available(iOS 13, *)
public struct ResponseAPDU {
  public var data: [Swift.UInt8]
  public var sw1: Swift.UInt8
  public var sw2: Swift.UInt8
  public init(data: [Swift.UInt8], sw1: Swift.UInt8, sw2: Swift.UInt8)
}
public protocol Delegate : AnyObject {
  typealias CDelegate = Swift.UnsafeMutablePointer<TensorFlowLiteC.TfLiteDelegate>
  var cDelegate: Self.CDelegate { get }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup15 : TestErhan.DataGroup {
  public var rsaPublicKey: Swift.OpaquePointer? {
    get
  }
  public var ecdsaPublicKey: Swift.OpaquePointer? {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationInfo : TestErhan.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
public class KnowYourX {
  public init(rootView view: UIKit.UIViewController, kyxDelegate delegate: any TestErhan.KnowYourXDelegate, kyxSettings settings: (any TestErhan.KYXSettingsProtocol)? = nil, account: TestErhan.KYXAccount)
  public func start()
  public func addViewtoSequence(sequenceView view: TestErhan.KYXViewController.Type, toAddPosition at: Swift.Int)
  @objc deinit
}
public enum KnowYourXOutputs {
  case success
  case failure
  case error(error: TestErhan.KYXError)
  case viewsHierarchy(views: [TestErhan.KYXViewController.Type])
  case finishProcess(result: TestErhan.KYXProcessModel)
}
public protocol KnowYourXDelegate : AnyObject {
  func output(_ kyxOutput: TestErhan.KnowYourXOutputs)
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class SecurityInfo {
  public func getObjectIdentifier() -> Swift.String
  public func getProtocolOIDString() -> Swift.String
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum DocTypeEnum : Swift.String {
  case TD1
  case TD2
  case OTHER
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup1 : TestErhan.DataGroup {
  public var elements: [Swift.String : Swift.String] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KYXHelper {
  public static func getImageAsset(assetName asset: Swift.String) -> UIKit.UIImage?
  @objc deinit
}
public func binToHexRep(_ val: [Swift.UInt8], asArray: Swift.Bool = false) -> Swift.String
public func binToHexRep(_ val: Swift.UInt8) -> Swift.String
public func binToHex(_ val: Swift.UInt8) -> Swift.Int
public func binToHex(_ val: [Swift.UInt8]) -> Swift.UInt64
public func binToHex(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.UInt64
public func hexToBin(_ val: Swift.UInt64) -> [Swift.UInt8]
public func binToInt(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.Int
public func binToInt(_ val: [Swift.UInt8]) -> Swift.Int
public func intToBin(_ data: Swift.Int, pad: Swift.Int = 2) -> [Swift.UInt8]
public func hexRepToBin(_ val: Swift.String) -> [Swift.UInt8]
public func xor(_ kifd: [Swift.UInt8], _ response_kicc: [Swift.UInt8]) -> [Swift.UInt8]
public func generateRandomUInt8Array(_ size: Swift.Int) -> [Swift.UInt8]
public func pad(_ toPad: [Swift.UInt8], blockSize: Swift.Int) -> [Swift.UInt8]
public func unpad(_ tounpad: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func mac(algoName: TestErhan.SecureMessagingSupportedAlgorithms, key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func desMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func aesMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func wrapDO(b: Swift.UInt8, arr: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func unwrapDO(tag: Swift.UInt8, wrappedData: [Swift.UInt8]) throws -> [Swift.UInt8]
public func intToBytes(val: Swift.Int, removePadding: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func oidToBytes(oid: Swift.String, replaceTag: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: Swift.ArraySlice<Swift.UInt8>) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: [Swift.UInt8]) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func toAsn1Length(_ data: Swift.Int) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcHash(data: [Swift.UInt8], hashAlgorithm: Swift.String) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA1Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA224Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA256Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA512Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA384Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
public struct KYXError {
}
public enum KYXErrors {
  case startManagerError
  case transactionStepError
  case startSequenceError
  case sequenceIndexError
  case viewHierarchCannotGet
  case signInError
  case tokenError
  case createTransactionError
  case updateTransactionStatusError
  public static func == (a: TestErhan.KYXErrors, b: TestErhan.KYXErrors) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, *)
public class TagReader {
  @objc deinit
}
public enum LogLevel : Swift.Int, Swift.CaseIterable {
  case verbose
  case debug
  case info
  case warning
  case error
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [TestErhan.LogLevel]
  public typealias RawValue = Swift.Int
  public static var allCases: [TestErhan.LogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Log {
  public static var logLevel: TestErhan.LogLevel
  public static var storeLogs: Swift.Bool
  public static var logData: [Swift.String]
  public class func verbose(_ msg: @autoclosure () -> Swift.String)
  public class func debug(_ msg: @autoclosure () -> Swift.String)
  public class func info(_ msg: @autoclosure () -> Swift.String)
  public class func warning(_ msg: @autoclosure () -> Swift.String)
  public class func error(_ msg: @autoclosure () -> Swift.String)
  public class func clearStoredLogs()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KYXLoading {
  public static let shared: TestErhan.KYXLoading
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup7 : TestErhan.DataGroup {
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
public enum QKMRZResult {
  case genericDocument(TestErhan.QKMRZResult.GenericDocument)
  case frenchID(TestErhan.QKMRZResult.FrenchID)
}
extension TestErhan.QKMRZResult {
  public struct GenericDocument {
    public var uuid: Foundation.UUID?
    public var documentType: Swift.String
    public var countryCode: Swift.String
    public var surnames: Swift.String
    public var givenNames: Swift.String
    public var documentNumber: Swift.String
    public var nationalityCountryCode: Swift.String
    public var birthdate: Foundation.Date?
    public var sex: Swift.String?
    public var expiryDate: Foundation.Date?
    public var personalNumber: Swift.String
    public var personalNumber2: Swift.String?
    public var isDocumentNumberValid: Swift.Bool
    public var isBirthdateValid: Swift.Bool
    public var isExpiryDateValid: Swift.Bool
    public var isPersonalNumberValid: Swift.Bool?
    public var allCheckDigitsValid: Swift.Bool
  }
}
extension TestErhan.QKMRZResult {
  public struct FrenchID {
    public let documentType: Swift.String
    public let countryCode: Swift.String
    public let lastName: Swift.String
    public let issuanceDepartment: Swift.String?
    public let issuanceOffice: Swift.String?
    public let issueDate: Swift.String
    public let issuanceDepartment2: Swift.String
    public let documentNumber: Swift.String
    public let firstName: Swift.String
    public let birthdate: Foundation.Date
    public let sex: Swift.String
    public let allCheckDigitsValid: Swift.Bool
  }
}
@objc public class KYXPerspectiveCorrectionParamsOperation : Foundation.Operation {
  public init(pixelBuffer: CoreVideo.CVImageBuffer, orientation: ImageIO.CGImagePropertyOrientation, rect: Vision.VNRectangleObservation)
  @objc override dynamic public func main()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SignatureRunner {
  final public let signatureKey: Swift.String
  final public var inputs: [Swift.String] {
    get
  }
  final public var outputs: [Swift.String] {
    get
  }
  @objc deinit
  final public func invoke(with inputs: [Swift.String : Foundation.Data]) throws
  final public func input(named name: Swift.String) throws -> TestErhan.Tensor
  final public func output(named name: Swift.String) throws -> TestErhan.Tensor
  final public func resizeInput(named name: Swift.String, toShape shape: TestErhan.Tensor.Shape) throws
  final public func copy(_ data: Foundation.Data, toInputNamed name: Swift.String) throws
  final public func allocateTensors() throws
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationPublicKeyInfo : TestErhan.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  @objc deinit
}
public struct KYXProcessModel {
}
public struct KYXProcessDetectTypeResult {
}
public struct KYXProcessNFCResult {
}
public struct KYXProcessLivenessResult {
}
public struct KYXProcessSpeechToTextResult {
}
public struct KYXProcessVideoCallResult {
}
public enum KYXDocumentType : Swift.String {
  case idCard
  case passport
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateType {
  case documentSigningCertificate
  case issuerSigningCertificate
  public static func == (a: TestErhan.CertificateType, b: TestErhan.CertificateType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateItem : Swift.String {
  case fingerprint
  case issuerName
  case subjectName
  case serialNumber
  case signatureAlgorithm
  case publicKeyAlgorithm
  case notBefore
  case notAfter
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class X509Wrapper {
  final public let cert: Swift.OpaquePointer
  public init?(with cert: Swift.OpaquePointer?)
  public func getItemsAsDict() -> [TestErhan.CertificateItem : Swift.String]
  public func certToPEM() -> Swift.String
  public func getFingerprint() -> Swift.String?
  public func getNotBeforeDate() -> Swift.String?
  public func getNotAfterDate() -> Swift.String?
  public func getSerialNumber() -> Swift.String?
  public func getSignatureAlgorithm() -> Swift.String?
  public func getPublicKeyAlgorithm() -> Swift.String?
  public func getIssuerName() -> Swift.String?
  public func getSubjectName() -> Swift.String?
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public class ASN1Item : Swift.CustomDebugStringConvertible {
  public init(line: Swift.String)
  public func getChild(_ child: Swift.Int) -> TestErhan.ASN1Item?
  public func getNumberOfChildren() -> Swift.Int
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public class SimpleASN1DumpParser {
  public init()
  public func parse(data: Foundation.Data) throws -> TestErhan.ASN1Item
  public func test()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup14 : TestErhan.DataGroup {
  public var securityInfos: [TestErhan.SecurityInfo] {
    get
  }
  @objc deinit
}
public struct Tensor : Swift.Equatable, Swift.Hashable {
  public let name: Swift.String
  public let dataType: TestErhan.Tensor.DataType
  public let shape: TestErhan.Tensor.Shape
  public let data: Foundation.Data
  public let quantizationParameters: TestErhan.QuantizationParameters?
  public static func == (a: TestErhan.Tensor, b: TestErhan.Tensor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TestErhan.Tensor {
  public enum DataType : Swift.Equatable, Swift.Hashable {
    case bool
    case uInt8
    case int16
    case int32
    case int64
    case float16
    case float32
    case float64
    public static func == (a: TestErhan.Tensor.DataType, b: TestErhan.Tensor.DataType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension TestErhan.Tensor {
  public struct Shape : Swift.Equatable, Swift.Hashable {
    public let rank: Swift.Int
    public let dimensions: [Swift.Int]
    public init(_ dimensions: [Swift.Int])
    public init(_ elements: Swift.Int...)
    public static func == (a: TestErhan.Tensor.Shape, b: TestErhan.Tensor.Shape) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension TestErhan.Tensor.Shape : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral: Swift.Int...)
  public typealias ArrayLiteralElement = Swift.Int
}
public enum KYXViewSettings {
  case withoutView
  case withView
  case customizableView
  public static func == (a: TestErhan.KYXViewSettings, b: TestErhan.KYXViewSettings) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Runtime {
  public static var version: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class CardAccess {
  public var securityInfos: [TestErhan.SecurityInfo] {
    get
  }
  @objc deinit
}
extension CoreVideo.CVBuffer {
  @available(iOS 13.0, *)
  public func sharpness() -> Swift.Float?
  public func cgImage(withOrientation orientation: ImageIO.CGImagePropertyOrientation) -> CoreGraphics.CGImage?
}
@available(iOS 13, macOS 10.15, *)
public enum NFCViewDisplayMessage {
  case requestPresentPassport
  case authenticatingWithPassport(Swift.Int)
  case readingDataGroupProgress(TestErhan.DataGroupId, Swift.Int)
  case error(TestErhan.NFCPassportReaderError)
  case successfulRead
}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.NFCViewDisplayMessage {
  public var description: Swift.String {
    get
  }
}
public enum KYXTransactionTypes {
  case fullTransaction
  case onlyCardTransaction
  case livenessTransaction
  case videoTransaction
  public static func == (a: TestErhan.KYXTransactionTypes, b: TestErhan.KYXTransactionTypes) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum InterpreterError : Swift.Error, Swift.Equatable, Swift.Hashable {
  case invalidTensorIndex(index: Swift.Int, maxIndex: Swift.Int)
  case invalidTensorDataCount(provided: Swift.Int, required: Swift.Int)
  case invalidTensorDataType
  case failedToLoadModel
  case failedToCreateInterpreter
  case failedToResizeInputTensor(index: Swift.Int)
  case failedToCopyDataToInputTensor
  case failedToAllocateTensors
  case allocateTensorsRequired
  case invokeInterpreterRequired
  case tensorFlowLiteError(Swift.String)
  public static func == (a: TestErhan.InterpreterError, b: TestErhan.InterpreterError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TestErhan.InterpreterError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension TestErhan.InterpreterError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class NotImplementedDG : TestErhan.DataGroup {
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public struct DataGroupHash {
  public var id: Swift.String
  public var sodHash: Swift.String
  public var computedHash: Swift.String
  public var match: Swift.Bool
}
@available(iOS 13, *)
public class BACHandler {
  public var ksenc: [Swift.UInt8]
  public var ksmac: [Swift.UInt8]
  public var kifd: [Swift.UInt8]
  public init()
  public init(tagReader: TestErhan.TagReader)
  public func performBACAndGetSessionKeys(mrzKey: Swift.String, completed: @escaping (_ error: TestErhan.NFCPassportReaderError?) -> ())
  public func sessionKeys(data: [Swift.UInt8]) throws -> ([Swift.UInt8], [Swift.UInt8], [Swift.UInt8])
  @objc deinit
}
public enum KYXStages : Swift.Int {
  case detectTypeFront
  case detectTypeBack
  case nfc
  case faceRecognation
  case liveness
  case speech
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public func AESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESECBEncrypt(key: [Swift.UInt8], message: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public enum DataGroupId : Swift.Int, Swift.CaseIterable {
  case COM
  case DG1
  case DG2
  case DG3
  case DG4
  case DG5
  case DG6
  case DG7
  case DG8
  case DG9
  case DG10
  case DG11
  case DG12
  case DG13
  case DG14
  case DG15
  case DG16
  case SOD
  case Unknown
  public func getName() -> Swift.String
  public static func getIDFromName(name: Swift.String) -> TestErhan.DataGroupId
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [TestErhan.DataGroupId]
  public typealias RawValue = Swift.Int
  public static var allCases: [TestErhan.DataGroupId] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public enum SignatureRunnerError : Swift.Error, Swift.Equatable, Swift.Hashable {
  case invalidTensorDataCount(provided: Swift.Int, required: Swift.Int)
  case invalidTensorDataType
  case failedToCreateSignatureRunner(signatureKey: Swift.String)
  case failedToGetTensor(tensorType: Swift.String, nameInSignature: Swift.String)
  case failedToResizeInputTensor(inputName: Swift.String)
  case failedToCopyDataToInputTensor
  case failedToAllocateTensors
  case failedToInvokeSignature(signatureKey: Swift.String)
  case allocateTensorsRequired
  public static func == (a: TestErhan.SignatureRunnerError, b: TestErhan.SignatureRunnerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TestErhan.SignatureRunnerError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension TestErhan.SignatureRunnerError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class COM : TestErhan.DataGroup {
  public var version: Swift.String {
    get
  }
  public var unicodeVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class Interpreter {
  final public let options: TestErhan.Interpreter.Options?
  final public let delegates: [any TestErhan.Delegate]?
  final public var inputTensorCount: Swift.Int {
    get
  }
  final public var outputTensorCount: Swift.Int {
    get
  }
  final public var signatureKeys: [Swift.String] {
    get
  }
  convenience public init(modelPath: Swift.String, options: TestErhan.Interpreter.Options? = nil, delegates: [any TestErhan.Delegate]? = nil) throws
  convenience public init(modelData: Foundation.Data, options: TestErhan.Interpreter.Options? = nil, delegates: [any TestErhan.Delegate]? = nil) throws
  @objc deinit
  final public func invoke() throws
  final public func input(at index: Swift.Int) throws -> TestErhan.Tensor
  final public func output(at index: Swift.Int) throws -> TestErhan.Tensor
  final public func resizeInput(at index: Swift.Int, to shape: TestErhan.Tensor.Shape) throws
  @discardableResult
  final public func copy(_ data: Foundation.Data, toInputAt index: Swift.Int) throws -> TestErhan.Tensor
  final public func allocateTensors() throws
  final public func signatureRunner(with key: Swift.String) throws -> TestErhan.SignatureRunner
}
extension TestErhan.Interpreter {
  public struct Options : Swift.Equatable, Swift.Hashable {
    public var threadCount: Swift.Int?
    public var isXNNPackEnabled: Swift.Bool
    public init()
    public static func == (a: TestErhan.Interpreter.Options, b: TestErhan.Interpreter.Options) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(*, deprecated, renamed: "Interpreter.Options")
public typealias InterpreterOptions = TestErhan.Interpreter.Options
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup12 : TestErhan.DataGroup {
  public var issuingAuthority: Swift.String? {
    get
  }
  public var dateOfIssue: Swift.String? {
    get
  }
  public var otherPersonsDetails: Swift.String? {
    get
  }
  public var endorsementsOrObservations: Swift.String? {
    get
  }
  public var taxOrExitRequirements: Swift.String? {
    get
  }
  public var frontImage: [Swift.UInt8]? {
    get
  }
  public var rearImage: [Swift.UInt8]? {
    get
  }
  public var personalizationTime: Swift.String? {
    get
  }
  public var personalizationDeviceSerialNr: Swift.String? {
    get
  }
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum NFCPassportReaderError : Swift.Error {
  case ResponseError(Swift.String, Swift.UInt8, Swift.UInt8)
  case InvalidResponse
  case UnexpectedError
  case NFCNotSupported
  case NoConnectedTag
  case D087Malformed
  case InvalidResponseChecksum
  case MissingMandatoryFields
  case CannotDecodeASN1Length
  case InvalidASN1Value
  case UnableToProtectAPDU
  case UnableToUnprotectAPDU
  case UnsupportedDataGroup
  case DataGroupNotRead
  case UnknownTag
  case UnknownImageFormat
  case NotImplemented
  case TagNotValid
  case ConnectionError
  case UserCanceled
  case InvalidMRZKey
  case MoreThanOneTagFound
  case InvalidHashAlgorithmSpecified
  case InvalidDataPassed(Swift.String)
  case NotYetSupported(Swift.String)
}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.NFCPassportReaderError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public enum OpenSSLError : Swift.Error {
  case UnableToGetX509CertificateFromPKCS7(Swift.String)
  case UnableToVerifyX509CertificateForSOD(Swift.String)
  case VerifyAndReturnSODEncapsulatedData(Swift.String)
  case UnableToReadECPublicKey(Swift.String)
  case UnableToExtractSignedDataFromPKCS7(Swift.String)
  case VerifySignedAttributes(Swift.String)
  case UnableToParseASN1(Swift.String)
  case UnableToDecryptRSASignature(Swift.String)
}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.OpenSSLError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum PassiveAuthenticationError : Swift.Error {
  case UnableToParseSODHashes(Swift.String)
  case InvalidDataGroupHash(Swift.String)
  case SODMissing(Swift.String)
}
extension TestErhan.PassiveAuthenticationError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol KYXSettingsProtocol : AnyObject {
  var viewSetting: TestErhan.KYXViewSettings { get }
  var transaction: TestErhan.KYXTransactionTypes { get }
}
public class KYXSettings : TestErhan.KYXSettingsProtocol {
  public var viewSetting: TestErhan.KYXViewSettings
  public var transaction: TestErhan.KYXTransactionTypes
  public init(viewSetting: TestErhan.KYXViewSettings = .withView, transaction: TestErhan.KYXTransactionTypes = .fullTransaction)
  @objc deinit
}
extension CoreMedia.CMSampleBuffer {
  public func cgImage(withOrientation orientation: ImageIO.CGImagePropertyOrientation) -> CoreGraphics.CGImage?
}
@objc @available(iOS 13, *)
public class PassportReader : ObjectiveC.NSObject {
  public var passiveAuthenticationUsesOpenSSL: Swift.Bool
  public init(logLevel: TestErhan.LogLevel = .info, masterListURL: Foundation.URL? = nil)
  public func setMasterListURL(_ masterListURL: Foundation.URL)
  public func overrideNFCDataAmountToRead(amount: Swift.Int)
  public func readPassport(mrzKey: Swift.String, tags: [TestErhan.DataGroupId] = [], skipSecureElements: Swift.Bool = true, skipCA: Swift.Bool = false, skipPACE: Swift.Bool = false, customDisplayMessage: ((TestErhan.NFCViewDisplayMessage) -> Swift.String?)? = nil, completed: @escaping (TestErhan.NFCPassportModel?, TestErhan.NFCPassportReaderError?) -> ())
  @objc deinit
}
@available(iOS 13, *)
extension TestErhan.PassportReader : CoreNFC.NFCTagReaderSessionDelegate {
  public func tagReaderSessionDidBecomeActive(_ session: CoreNFC.NFCTagReaderSession)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didInvalidateWithError error: any Swift.Error)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didDetect tags: [CoreNFC.NFCTag])
}
public struct QuantizationParameters : Swift.Equatable, Swift.Hashable {
  public let scale: Swift.Float
  public let zeroPoint: Swift.Int
  public static func == (a: TestErhan.QuantizationParameters, b: TestErhan.QuantizationParameters) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TestErhan.PassportAuthenticationStatus : Swift.Equatable {}
extension TestErhan.PassportAuthenticationStatus : Swift.Hashable {}
extension TestErhan.SecureMessagingSupportedAlgorithms : Swift.Equatable {}
extension TestErhan.SecureMessagingSupportedAlgorithms : Swift.Hashable {}
extension TestErhan.PACEMappingType : Swift.Equatable {}
extension TestErhan.PACEMappingType : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.DocTypeEnum : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.DocTypeEnum : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.DocTypeEnum : Swift.RawRepresentable {}
extension TestErhan.KYXErrors : Swift.Equatable {}
extension TestErhan.KYXErrors : Swift.Hashable {}
extension TestErhan.LogLevel : Swift.Equatable {}
extension TestErhan.LogLevel : Swift.Hashable {}
extension TestErhan.LogLevel : Swift.RawRepresentable {}
extension TestErhan.KYXDocumentType : Swift.Equatable {}
extension TestErhan.KYXDocumentType : Swift.Hashable {}
extension TestErhan.KYXDocumentType : Swift.RawRepresentable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.CertificateType : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.CertificateType : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.CertificateItem : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.CertificateItem : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.CertificateItem : Swift.RawRepresentable {}
extension TestErhan.KYXViewSettings : Swift.Equatable {}
extension TestErhan.KYXViewSettings : Swift.Hashable {}
extension TestErhan.KYXTransactionTypes : Swift.Equatable {}
extension TestErhan.KYXTransactionTypes : Swift.Hashable {}
extension TestErhan.KYXStages : Swift.Equatable {}
extension TestErhan.KYXStages : Swift.Hashable {}
extension TestErhan.KYXStages : Swift.RawRepresentable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.DataGroupId : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.DataGroupId : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TestErhan.DataGroupId : Swift.RawRepresentable {}
